// THIS FILE WAS AUTOMATICALLY GENERATED BY dwave/gate/simulator/operation_generation.py
#include <complex.h>
#include <algorithm>


void single_qubit(int num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, int target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  std::complex<double> gate_value00 = gate_matrix[0];
  std::complex<double> gate_value01 = gate_matrix[1];
  std::complex<double> gate_value10 = gate_matrix[2];
  std::complex<double> gate_value11 = gate_matrix[3];
  #pragma omp parallel for
  for (uint64_t idx = 0; idx < (num_states >> 1); idx++)
  {
    uint64_t state_idx_mask = idx;
    state_idx_mask = ((state_idx_mask & ~mask0) << 1) | (state_idx_mask & mask0);
    state_idx_mask = state_idx_mask | control_mask;
    uint64_t state0 = state_idx_mask | target_mask0;
    uint64_t state1 = state_idx_mask | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    state_vector[state0] = (gate_value00 * amp0) + (gate_value01 * amp1);
    state_vector[state1] = (gate_value10 * amp0) + (gate_value11 * amp1);
  }
}

void apply_gate_control(int num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, int target0, int control0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0, control0};
  std::sort(positions, positions + 2);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t control_mask = 0 | (1 << control0);
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  std::complex<double> gate_value00 = gate_matrix[0];
  std::complex<double> gate_value01 = gate_matrix[1];
  std::complex<double> gate_value10 = gate_matrix[2];
  std::complex<double> gate_value11 = gate_matrix[3];
  #pragma omp parallel for
  for (uint64_t idx = 0; idx < (num_states >> 2); idx++)
  {
    uint64_t state_idx_mask = idx;
    state_idx_mask = ((state_idx_mask & ~mask0) << 1) | (state_idx_mask & mask0);
    state_idx_mask = ((state_idx_mask & ~mask1) << 1) | (state_idx_mask & mask1);
    state_idx_mask = state_idx_mask | control_mask;
    uint64_t state0 = state_idx_mask | target_mask0;
    uint64_t state1 = state_idx_mask | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    state_vector[state0] = (gate_value00 * amp0) + (gate_value01 * amp1);
    state_vector[state1] = (gate_value10 * amp0) + (gate_value11 * amp1);
  }
}

void apply_gate_two_control(int num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, int target0, int control0, int control1)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0, control0, control1};
  std::sort(positions, positions + 3);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t mask2 = (1 << positions[2]) - 1;
  uint64_t control_mask = 0 | (1 << control0) | (1 << control1);
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  std::complex<double> gate_value00 = gate_matrix[0];
  std::complex<double> gate_value01 = gate_matrix[1];
  std::complex<double> gate_value10 = gate_matrix[2];
  std::complex<double> gate_value11 = gate_matrix[3];
  #pragma omp parallel for
  for (uint64_t idx = 0; idx < (num_states >> 3); idx++)
  {
    uint64_t state_idx_mask = idx;
    state_idx_mask = ((state_idx_mask & ~mask0) << 1) | (state_idx_mask & mask0);
    state_idx_mask = ((state_idx_mask & ~mask1) << 1) | (state_idx_mask & mask1);
    state_idx_mask = ((state_idx_mask & ~mask2) << 1) | (state_idx_mask & mask2);
    state_idx_mask = state_idx_mask | control_mask;
    uint64_t state0 = state_idx_mask | target_mask0;
    uint64_t state1 = state_idx_mask | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    state_vector[state0] = (gate_value00 * amp0) + (gate_value01 * amp1);
    state_vector[state1] = (gate_value10 * amp0) + (gate_value11 * amp1);
  }
}

void apply_swap(int num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, int target0, int target1)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0, target1};
  std::sort(positions, positions + 2);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask1 = 0 | (1 << target0) | (0 << target1);
  uint64_t target_mask2 = 0 | (0 << target0) | (1 << target1);
  #pragma omp parallel for
  for (uint64_t idx = 0; idx < (num_states >> 2); idx++)
  {
    uint64_t state_idx_mask = idx;
    state_idx_mask = ((state_idx_mask & ~mask0) << 1) | (state_idx_mask & mask0);
    state_idx_mask = ((state_idx_mask & ~mask1) << 1) | (state_idx_mask & mask1);
    state_idx_mask = state_idx_mask | control_mask;
    uint64_t state1 = state_idx_mask | target_mask1;
    uint64_t state2 = state_idx_mask | target_mask2;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp2 = state_vector[state2];
    state_vector[state1] = amp2;
    state_vector[state2] = amp1;
  }
}

void apply_cswap(int num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, int target0, int target1, int control0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0, target1, control0};
  std::sort(positions, positions + 3);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t mask1 = (1 << positions[1]) - 1;
  uint64_t mask2 = (1 << positions[2]) - 1;
  uint64_t control_mask = 0 | (1 << control0);
  uint64_t target_mask1 = 0 | (1 << target0) | (0 << target1);
  uint64_t target_mask2 = 0 | (0 << target0) | (1 << target1);
  #pragma omp parallel for
  for (uint64_t idx = 0; idx < (num_states >> 3); idx++)
  {
    uint64_t state_idx_mask = idx;
    state_idx_mask = ((state_idx_mask & ~mask0) << 1) | (state_idx_mask & mask0);
    state_idx_mask = ((state_idx_mask & ~mask1) << 1) | (state_idx_mask & mask1);
    state_idx_mask = ((state_idx_mask & ~mask2) << 1) | (state_idx_mask & mask2);
    state_idx_mask = state_idx_mask | control_mask;
    uint64_t state1 = state_idx_mask | target_mask1;
    uint64_t state2 = state_idx_mask | target_mask2;
    std::complex<double> amp1 = state_vector[state1];
    std::complex<double> amp2 = state_vector[state2];
    state_vector[state1] = amp2;
    state_vector[state2] = amp1;
  }
}

void apply_dephase_0(int num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, int target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  #pragma omp parallel for
  for (uint64_t idx = 0; idx < (num_states >> 1); idx++)
  {
    uint64_t state_idx_mask = idx;
    state_idx_mask = ((state_idx_mask & ~mask0) << 1) | (state_idx_mask & mask0);
    state_idx_mask = state_idx_mask | control_mask;
    uint64_t state0 = state_idx_mask | target_mask0;
    uint64_t state1 = state_idx_mask | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    state_vector[state0] = (0.99498743710662 * amp0);
    state_vector[state1] = (0.99498743710662 * amp1);
  }
}

void apply_dephase_1(int num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, int target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  #pragma omp parallel for
  for (uint64_t idx = 0; idx < (num_states >> 1); idx++)
  {
    uint64_t state_idx_mask = idx;
    state_idx_mask = ((state_idx_mask & ~mask0) << 1) | (state_idx_mask & mask0);
    state_idx_mask = state_idx_mask | control_mask;
    uint64_t state0 = state_idx_mask | target_mask0;
    uint64_t state1 = state_idx_mask | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    state_vector[state0] = (0.1 * amp0);
    state_vector[state1] = (-0.1 * amp1);
  }
}

void apply_amp_damp_0(int num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, int target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask1 = 0 | (1 << target0);
  #pragma omp parallel for
  for (uint64_t idx = 0; idx < (num_states >> 1); idx++)
  {
    uint64_t state_idx_mask = idx;
    state_idx_mask = ((state_idx_mask & ~mask0) << 1) | (state_idx_mask & mask0);
    state_idx_mask = state_idx_mask | control_mask;
    uint64_t state1 = state_idx_mask | target_mask1;
    std::complex<double> amp1 = state_vector[state1];
    state_vector[state1] = (0.99498743710662 * amp1);
  }
}

void apply_amp_damp_1(int num_qubits, std::complex<double> *state_vector, std::complex<double> *gate_matrix, int target0)
{
  uint64_t num_states = 1 << num_qubits;
  uint64_t positions[] = {target0};
  std::sort(positions, positions + 1);
  uint64_t mask0 = (1 << positions[0]) - 1;
  uint64_t control_mask = 0;
  uint64_t target_mask0 = 0 | (0 << target0);
  uint64_t target_mask1 = 0 | (1 << target0);
  #pragma omp parallel for
  for (uint64_t idx = 0; idx < (num_states >> 1); idx++)
  {
    uint64_t state_idx_mask = idx;
    state_idx_mask = ((state_idx_mask & ~mask0) << 1) | (state_idx_mask & mask0);
    state_idx_mask = state_idx_mask | control_mask;
    uint64_t state0 = state_idx_mask | target_mask0;
    uint64_t state1 = state_idx_mask | target_mask1;
    std::complex<double> amp0 = state_vector[state0];
    std::complex<double> amp1 = state_vector[state1];
    state_vector[state0] = (0.1 * amp1);
    state_vector[state1] = 0.0;
  }
}

